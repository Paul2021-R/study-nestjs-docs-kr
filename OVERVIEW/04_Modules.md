### Modules
`@Module()` 데코레이터를 어노테이션으로 달고 있는 클래스를 모듈이라고 부릅니다. `@Module()` 데코레이터는 Nest 가 어플리케이션의 구조를 조직화하는데 사용하는 메타 데이터들을 제공해줍니다.

![](../src/04_01.png)

각 어플리케이션은 최소 하나의 모듈을 가지고 있고, 이를 `root` 모듈이라고 부릅니다. 루트모듈은 **어플리케이션 그래프** 를 생성하기위해 Nest가 사용하는 스타팅 포인트 역할을 합니다. application graph 라는 것은 Nest에서 모듈과 프로바이더 사이의 관련성, 의존성을 해결하기 위해 사용하는 것입니다. 이론적으로 작은 어플리케이션이라면 루트 모듈만 존재할 수도 있지만, 보통 일반적인 경우 그렇지 않습니다. 또한 Nest 에서는 당신의 컴포넌트 들을 조직화 할 때 효과적인 방법으로 가장 강력히 추천하는 것이 모듈형태로 사용하는 것을 강조하고 싶습니다. 따라서 대부분의 애플리케이션에서 결과 아키텍처는 여러 모듈을 사용하며 각 모듈은 밀접하게 관련된 기능 세트를 캡슐화하는 구조가 될 것입니다. 

`@Module()` 데코레이터는 모듈을 묘사하기 위한 프로퍼티를 가진 단일 객체를 취합니다. 

| 이름 | 설명 |
|:---- | :--- |
|providers|프로바이더는 Nest 의 주입기에 의해 인스턴스화 하며, 특정 모듈을 최소 넘어서서 공유될 것입니다. |
|controllers|특정 모듈에 정의 내려진 일련의 컨트롤러들은 반드시 인스턴스화 되어야 합니다.| 
|imports|해당 모듈 안에서 필요로 되어지는 프로바이더들을 export하는 모듈들의 리스트입니다.|
|exports|프로바이더들의 하위 셋으로, 이는 특정 이 모듈에 의해 제공되는 기능들로 볼 수 있으며, 이는 다른 모듈에 의해 이용이 가능한 일련의 프로바이더들을 담고 있습니다. 당신은 여기서도 프로바이더 자체를 혹은 단순히 `provide` 값의 토큰 만을 제공할 수도 있습니다.|

모들은 기본적으로 프로바이더들을 '캡슐화'합니다. 이는 현재 모듈의 직접 일부도 아니고 가져온 모듈에서 내보내지지도 않은 공급자를 주입하는 것이 불가능하다는 것을 의미합니다. 따라서 모듈에서 내보낸 공급자(exported Providers)를 모듈의 공용 인터페이스 또는 API로 간주할 수 있습니다

### Features modules 
### Shared modules
### Module re-exporting
### Dependency injection 
### Global modules 
### Dynamic moudles 